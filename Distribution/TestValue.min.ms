/*! Â© 2022 imaoki | MIT License | https://github.com/imaoki */;struct TestValueStruct (public _CP1_,public IgnoreCase = false,private v,private regexClass = DotNetClass "System.Text.RegularExpressions.Regex",private regexType,public fn CountEquals count = (local result = false;case of ((this.IsArrayOrArrayParameter()): result = this.v.Count == count;(this.IsBitArray()): result = this.v.NumberSet == count;(this.IsDictionary()): result = this.v.Count == count;default: (););result;),public fn CountGreaterOrEquals count = (local result = false;case of ((this.IsArrayOrArrayParameter()): result = this.v.Count >= count;(this.IsBitArray()): result = this.v.NumberSet >= count;(this.IsDictionary()): result = this.v.Count >= count;default: (););result;),public fn CountGreaterThan count = (local result = false;case of ((this.IsArrayOrArrayParameter()): result = this.v.Count > count;(this.IsBitArray()): result = this.v.NumberSet > count;(this.IsDictionary()): result = this.v.Count > count;default: (););result;),public fn CountLessOrEquals count = (local result = false;case of ((this.IsArrayOrArrayParameter()): result = this.v.Count <= count;(this.IsBitArray()): result = this.v.NumberSet <= count;(this.IsDictionary()): result = this.v.Count <= count;default: (););result;),public fn CountLessThan count = (local result = false;case of ((this.IsArrayOrArrayParameter()): result = this.v.Count < count;(this.IsBitArray()): result = this.v.NumberSet < count;(this.IsDictionary()): result = this.v.Count < count;default: (););result;),public fn GetValue = (this.v;),public fn HasEquals = (this.HasProp #Equals and (classOf this.v.Equals == MaxScriptFunction or classOf this.v.Equals == DotNetMethod;);),public fn HasProp propName = (isProperty this.v propName;),public fn Install = (if isProperty ::startupLoader #RegisterFile do (::startupLoader.RegisterFile (getSourceFileName()););format "[install]::TestValueStruct\n";ok;),public fn Uninstall = (if isProperty ::startupLoader #UnregisterFile do (::startupLoader.UnregisterFile (getSourceFileName()););format "[uninstall]::TestValueStruct\n";ok;),public fn IsAngleAxis = classOf this.v == AngleAxis,public fn IsArray = classOf this.v == Array,public fn IsArrayOrArrayParameter = this.IsArray() or this.IsArrayParameter(),public fn IsArrayParameter = classOf this.v == ArrayParameter,public fn IsAttributeDef = classOf this.v == AttributeDef,public fn IsBigMatrix = classOf this.v == BigMatrix,public fn IsBinStream = classOf this.v == BinStream,public fn IsBitArray = classOf this.v == BitArray,public fn IsBitmap = classOf this.v == Bitmap,public fn IsBoolean = classOf this.v == BooleanClass,public fn IsBox2 = classOf this.v == Box2,public fn IsBox3 = classOf this.v == Box3,public fn IsColor = classOf this.v == Color,public fn IsDataPair = classOf this.v == DataPair,public fn IsDictionary = classOf this.v == Dictionary,public fn IsDotNetClass = classOf this.v == DotNetClass,public fn IsDotNetMethod = classOf this.v == DotNetMethod,public fn IsDotNetObject = classOf this.v == DotNetObject,public fn IsEulerAngles = classOf this.v == EulerAngles,public fn IsFileStream = classOf this.v == FileStream,public fn IsFloat = classOf this.v == Float,public fn IsInteger = classOf this.v == Integer,public fn IsInterval = classOf this.v == Interval,public fn IsMatrix3 = classOf this.v == Matrix3,public fn IsMAXKey = classOf this.v == MAXKey,public fn IsMAXScriptFunction = classOf this.v == MAXScriptFunction,public fn IsName = classOf this.v == Name,public fn IsNumber = superClassOf this.v == Number,public fn IsOk = classOf this.v == OkClass,public fn IsPoint2 = classOf this.v == Point2,public fn IsPoint3 = classOf this.v == Point3,public fn IsPoint4 = classOf this.v == Point4,public fn IsQuat = classOf this.v == Quat,public fn IsRay = classOf this.v == Ray,public fn IsRegexObject = classOf this.v == DotNetObject and this.regexType.IsInstanceOfType this.v,public fn IsRollout = classOf this.v == RolloutClass,public fn IsString = classOf this.v == String,public fn IsStringStream = classOf this.v == StringStream,public fn IsStructDefinition = isStructDef this.v,public fn IsStructInstance = isStruct this.v,public fn IsTestValue obj = classOf obj == classOf this,public fn IsTime = classOf this.v == Time,public fn IsUndefined = classOf this.v == UndefinedClass,public fn IsUnsupplied = classOf this.v == UnsuppliedClass,public fn IsWindowStream = classOf this.v == WindowStream,private fn escapeBackslash input = (local result = input as String;result = substituteString result "\\" "\\\\";result = substituteString result "\"" "\\\"";result = substituteString result "\n" "\\n";result = substituteString result "\r" "\\r";result = substituteString result "\t" "\\t";result;),private fn valueToString input = (local result = "";case classOf input of ((Array): (result = "#(";for i = 1 to input.Count do (if i > 1 do (result += ", ";);local elementValue = this.valueToString input[i];if classOf input[i] == String do (elementValue = "\"" + elementValue + "\"";);result += elementValue;);result += ")";);(DataPair): (local propNames = getPropNames input;local isExplicitPropNames = propNames.Count == 4;local v1Value = this.valueToString input.V1;local v2Value = this.valueToString input.V2;if classOf input.V1 == String do (v1Value = "\"" + v1Value + "\"";);if classOf input.V2 == String do (v2Value = "\"" + v2Value + "\"";);if isExplicitPropNames do (local v1Name = propNames[3] as String;local v2Name = propNames[4] as String;v1Name = (DotNetObject "System.String" v1Name).TrimStart "#";v2Name = (DotNetObject "System.String" v2Name).TrimStart "#";v1Value = v1Name + ":" + v1Value;v2Value = v2Name + ":" + v2Value;);result = "DataPair " + v1Value + " " + v2Value;);(Dictionary): (result += "Dictionary " + (this.valueToString input.Type);for key in input.Keys do (local keyText = this.valueToString key;local valueText = this.valueToString (input[key]);if classOf key == String do (keyText = "\"" + keyText + "\"";);if classOf input[key] == String do (valueText = "\"" + valueText + "\"";);result += " #(" + keyText + ", " + valueText + ")";););(Float): (result += formattedPrint input format:"f";);(StringStream): (result += "StringStream ";result += "\"" + (this.valueToString (input as String)) + "\"";);default : (result = input as String;case classOf input of ((Name): result = "#" + result;(String): result = this.escapeBackslash result;default: (););););result;),public fn StructName = #TestValueStruct,public fn Dump indent:"" out:listener = (format "%TestValueStruct\n" indent to:out;format "%  IgnoreCase:%\n" indent this.IgnoreCase to:out;if this.HasProp #Dump and classOf this.v.Dump == MAXScriptFunction then (format "%  v:\n" indent to:out;this.v.Dump indent:(indent + "    ") out:out;);else (if classOf this.v == String then (format "%  v:\"%\"\n" indent (this.valueToString this.v) to:out;);else (format "%  v:%\n" indent (this.valueToString this.v) to:out;););ok;),public fn Equals obj = (local isEqualStructName = isStruct obj and isProperty obj #StructName and classOf obj.StructName == MAXScriptFunction and obj.StructName() == this.StructName();local isEqualProperties = isProperty obj #GetValue and classOf obj.GetValue == MAXScriptFunction;if isEqualProperties do (local ov = obj.GetValue();local tv = this.GetValue();local testValueDef = classOf this;isEqualProperties = case of ((this.IsAngleAxis() and obj.IsAngleAxis()): (local t1 = testValueDef tv.Angle;local t2 = testValueDef tv.Axis;local t3 = testValueDef tv.NumRevs;local o1 = testValueDef ov.Angle;local o2 = testValueDef ov.Axis;local o3 = testValueDef ov.NumRevs;t1.Equals o1 and t2.Equals o2 and t3.Equals o3;);(this.IsArrayOrArrayParameter() and obj.IsArrayOrArrayParameter()): (local result = ov.Count == tv.Count;for i = 1 to tv.Count while result do (local t1 = testValueDef tv[i];local o1 = testValueDef ov[i];result = t1.Equals o1;);result;);(this.IsBigMatrix() and obj.IsBigMatrix()): (local result = ov.Rows == tv.Rows and ov.Columns == tv.Columns;for i = 1 to tv.Rows while result do (for j = 1 to tv.Columns while result do (local t1 = testValueDef tv[i][j];local o1 = testValueDef ov[i][j];result = t1.Equals o1;););result;);(this.IsBitArray() and obj.IsBitArray()): (tv.NumberSet == ov.NumberSet and (tv * ov).NumberSet == tv.NumberSet;);(this.IsBox2() and obj.IsBox2()): (local t1 = testValueDef tv.X;local t2 = testValueDef tv.Y;local t3 = testValueDef tv.W;local t4 = testValueDef tv.H;local o1 = testValueDef ov.X;local o2 = testValueDef ov.Y;local o3 = testValueDef ov.W;local o4 = testValueDef ov.H;t1.Equals o1 and t2.Equals o2 and t3.Equals o3 and t4.Equals o4;);(this.IsBox3() and obj.IsBox3()): (local t1 = testValueDef tv.Min;local t2 = testValueDef tv.Max;local o1 = testValueDef ov.Min;local o2 = testValueDef ov.Max;t1.Equals o1 and t2.Equals o2;);(this.IsDataPair() and obj.IsDataPair()): (local t1 = testValueDef tv.V1;local t2 = testValueDef tv.V2;local t3 = testValueDef (getPropNames tv);local o1 = testValueDef ov.V1;local o2 = testValueDef ov.V2;local o3 = testValueDef (getPropNames ov);t1.Equals o1 and t2.Equals o2 and t3.Equals o3;);(this.IsDictionary() and obj.IsDictionary()): (local result = ov.Type == tv.Type and ov.Count == tv.Count;for key in tv.Keys while result do (local t1 = testValueDef (hasDictValue tv key);local t2 = testValueDef tv[key];local o1 = testValueDef (hasDictValue ov key);local o2 = testValueDef ov[key];result = t1.Equals o1 and t2.Equals o2;);result;);(this.IsEulerAngles() and obj.IsEulerAngles()): (local t1 = testValueDef tv.X;local t2 = testValueDef tv.Y;local t3 = testValueDef tv.Z;local o1 = testValueDef ov.X;local o2 = testValueDef ov.Y;local o3 = testValueDef ov.Z;t1.Equals o1 and t2.Equals o2 and t3.Equals o3;);(this.IsInterval() and obj.IsInterval()): (local t1 = testValueDef tv.Start;local t2 = testValueDef tv.End;local o1 = testValueDef ov.Start;local o2 = testValueDef ov.End;t1.Equals o1 and t2.Equals o2;);(this.IsMatrix3() and obj.IsMatrix3()): (local t1 = testValueDef tv[1];local t2 = testValueDef tv[2];local t3 = testValueDef tv[3];local t4 = testValueDef tv[4];local o1 = testValueDef ov[1];local o2 = testValueDef ov[2];local o3 = testValueDef ov[3];local o4 = testValueDef ov[4];t1.Equals o1 and t2.Equals o2 and t3.Equals o3 and t4.Equals o4;);(this.IsNumber() and obj.IsNumber()): (local f1 = ov as Float + 1.0;local f2 = tv as Float + 1.0;close_enough f1 f2 10;);(this.IsPoint2() and obj.IsPoint2()): (local t1 = testValueDef tv.X;local t2 = testValueDef tv.Y;local o1 = testValueDef ov.X;local o2 = testValueDef ov.Y;t1.Equals o1 and t2.Equals o2;);(this.IsPoint3() and obj.IsPoint3()): (local t1 = testValueDef tv.X;local t2 = testValueDef tv.Y;local t3 = testValueDef tv.Z;local o1 = testValueDef ov.X;local o2 = testValueDef ov.Y;local o3 = testValueDef ov.Z;t1.Equals o1 and t2.Equals o2 and t3.Equals o3;);(this.IsPoint4() and obj.IsPoint4()): (local t1 = testValueDef tv.X;local t2 = testValueDef tv.Y;local t3 = testValueDef tv.Z;local t4 = testValueDef tv.W;local o1 = testValueDef ov.X;local o2 = testValueDef ov.Y;local o3 = testValueDef ov.Z;local o4 = testValueDef ov.W;t1.Equals o1 and t2.Equals o2 and t3.Equals o3 and t4.Equals o4;);(this.IsQuat() and obj.IsQuat()): (local t1 = testValueDef tv.Angle;local t2 = testValueDef tv.Axis;local o1 = testValueDef ov.Angle;local o2 = testValueDef ov.Axis;t1.Equals o1 and t2.Equals o2;);(this.IsRay() and obj.IsRay()): (local t1 = testValueDef tv.Pos;local t2 = testValueDef tv.Dir;local o1 = testValueDef ov.Pos;local o2 = testValueDef ov.Dir;t1.Equals o1 and t2.Equals o2;);(this.IsRegexObject() and obj.IsRegexObject()): (local t1 = testValueDef (tv.ToString());local t2 = testValueDef tv.Options;local o1 = testValueDef (ov.ToString());local o2 = testValueDef ov.Options;t1.Equals o1 and t2.Equals o2;);(this.IsString() and obj.IsString()): (if this.IgnoreCase then (stricmp ov tv == 0;);else (ov == tv;););default: (if this.HasEquals() and not this.IsDotNetClass() then (tv.Equals ov;);else (ov == tv;););););isEqualStructName and isEqualProperties;),on Create do (this.regexType = (DotNetObject this.regexClass "").GetType();this.v = this._CP1_;););::TestValueStruct.Install();::TestValueStruct
